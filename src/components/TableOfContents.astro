---
import type { MarkdownHeading } from 'astro'

type Props = {
  headings: MarkdownHeading[]
}

type HeadingWithSubheadings = MarkdownHeading & {
  subheadings: MarkdownHeading[]
}

const { headings } = Astro.props

const grouppedHeadings = headings.reduce((array, heading) => {
  if (heading.depth === 2) {
    array.push({ ...heading, subheadings: [] })
  } else if (heading.depth === 3) {
    array.at(-1)?.subheadings.push(heading)
  }

  return array
}, [] as HeadingWithSubheadings[])
---

<nav
  id="table-of-contents"
  class="not-prose text-sm"
  aria-label="Table Of Contents"
>
  <ol>
    {
      grouppedHeadings.map((h) => (
        <li>
          <a
            href={`#${h.slug}`}
            class="unset animated-link data-[active=true]:font-bold data-[active=true]:show"
            data-active="false"
          >
            {h.text}
          </a>
          {h.subheadings.length > 0 && (
            <ol>
              {h.subheadings.map((sub) => (
                <li>
                  <a
                    href={`#${sub.slug}`}
                    class="unset animated-link data-[active=true]:font-bold data-[active=true]:show"
                    data-active="false"
                  >
                    {sub.text}
                  </a>
                </li>
              ))}
            </ol>
          )}
        </li>
      ))
    }
  </ol>
</nav>

<script is:inline>
  document.addEventListener(
    'astro:page-load',
    () => {
      const observer = new IntersectionObserver(
        (entries) => {
          for (const entry of entries) {
            const headingFragment = `#${entry.target.id}`
            const tocItem = document.querySelector(
              `a[href="${headingFragment}"]`
            )

            if (entry.isIntersecting) {
              /** @type {HTMLAnchorElement | null} */
              const previouslyActivatedItem = document.querySelector(
                '[data-active="true"]'
              )

              if (previouslyActivatedItem) {
                previouslyActivatedItem.dataset.active = 'false'
              }
              tocItem.dataset.active = 'true'
            } else {
              const isAnyOtherEntryIntersecting = entries.some(
                (e) => e.target.id !== entry.target.id && e.isIntersecting
              )

              if (isAnyOtherEntryIntersecting) {
                tocItem.dataset.active = 'false'
              }
            }
          }
        },
        { root: null, rootMargin: '0px', threshold: [1] }
      )

      const sectionHeadings = document.querySelectorAll(
        'article > h2, article > h3'
      )

      for (const heading of sectionHeadings) {
        observer.observe(heading)
      }
    },
    { once: true }
  )
</script>
